<?php
/**
 * Contains the push class
 */

namespace Huhu\Library;

/**
 * Class \Huhu\Library\Push
 * Methods required for the push scripts
 */
class Push
{
  /**
   * @var array contains the pusher \Huhu\Library\Pusher instances (the derived classes, APN_Pusher, GCM_Pusher or Websocket_Pusher) for the user ids to push to
   */
  private static $_pusherInstancesForUserIds=Array();


  /**
   * Push to one or more users
   * @param $receiverUserIDs
   * @param $data
   */
  public static function push($receiverUserIDs, $data) {

    if (!is_array($receiverUserIDs)) $receiverUserIDs=Array($receiverUserIDs);

    foreach ($receiverUserIDs as $userId) {
      // for each receiver generate a pusher instance if not present
      if (!isset(self::$_pusherInstancesForUserIds[$userId])) {
        self::$_pusherInstancesForUserIds[$userId]=self::initPusher($userId);
      }

      // send the message
      foreach (self::$_pusherInstancesForUserIds[$userId] as $instance) {
        $instance->push($data);
      }
    }



  }


  /**
   * Calls the factory of APN, GCM or Websocket pusher, depending on the push methods available for the given user
   * @param $userId
   * @return Array
   */
  public static function initPusher($userId) {
    // get all valid push methods for this user
    $instances=Array();
    $pushMethods=self::getUserMethods($userId);

    if (is_array($pushMethods)) {
      foreach ($pushMethods as $method) {
        $instances[]=\Huhu\Library\Pusher::factory($method['method'], $userId);
      }
    }

    return $instances;
  }


  /**
   * returns all available push methods for loggedin user
   * @param int $userId
   * @return bool
   */
  public static function getUserMethods($userId) {
    $db=\Zend_Registry::get('Zend_Db');
    $mc=\Zend_Registry::get('Zend_Cache');

    $pushMethods=$mc->load(\Huhu\Library\MemcacheManager::getKeyUserPushMethods($userId));
    if ($pushMethods !== FALSE && is_array($pushMethods)) {
      // if we got data from memcache, check if validations expired. If one expired found, invalidate cache
      foreach ($pushMethods as $method) {
        if ($method['valid_until'] < date('Y-m-d H:i:s')) {
          $pushMethods=FALSE;
          break;
        }
      }
    }

    if ($pushMethods===FALSE) {
      $stmt=$db->prepare('SELECT `method`, `token`, `valid_until` FROM user_push_auth WHERE fk_userID=?');
      if ($stmt->execute(Array($userId))) {
        $rows=$stmt->fetchAll(\Zend_Db::FETCH_ASSOC);
        foreach ($rows as $row) {
          if ($row['valid_until'] > date('Y-m-d H:i:s')) {
            $pushMethods[$row['method']]=$row;
          }

          $mc->save($pushMethods, \Huhu\Library\MemcacheManager::getKeyUserPushMethods($userId));
        }
      }
    }

    return $pushMethods;
  }


  /**
   * accepts the googleCloudMessage regID, generated by app
   * and stores it to the pushauth db
   * @param $regId
   * @return Boolean success
   */
  public static function pushauthSetGcmRegid($regId) {
    \Huhu\Library\Auth::auth();
    $db=\Zend_Registry::get('Zend_Db');
    $currentUser=\Zend_Registry::get('loggedinuser');

    $stmt=$db->prepare("INSERT INTO user_push_auth (`fk_userID`, `method`, `token`, `valid_until`)
                          VALUES(:fk_userID, :method, :token, :valid_until)
                          ON DUPLICATE KEY UPDATE `token`=:token, `valid_until`=:valid_until;");
    $params=Array(
      ':fk_userID' => $currentUser['id'],
      ':method' => 'gcm',
      ':token' => $regId,
      ':valid_until' => date('Y-m-d H:i:s', time() + 604800), // 7-days
    );

    if ($stmt->execute($params)) {
      \Huhu\Library\MemcacheManager::invalidateOnPushMethodsChange($currentUser['id']);
      return TRUE;
    }

    return FALSE;
  }


  /**
   * accepts the Apple APN token generated by app
   * and stores it to the pushauth db
   * @param $token
   * @return Boolean success
   */
  public static function pushauthSetApnToken($token) {
    \Huhu\Library\Auth::auth();
    $db=\Zend_Registry::get('Zend_Db');
    $currentUser=\Zend_Registry::get('loggedinuser');

    $stmt=$db->prepare("INSERT INTO user_push_auth (`fk_userID`, `method`, `token`, `valid_until`)
                          VALUES(:fk_userID, :method, :token, :valid_until)
                          ON DUPLICATE KEY UPDATE `token`=:token, `valid_until`=:valid_until;");
    $params=Array(
      ':fk_userID' => $currentUser['id'],
      ':method' => 'apn',
      ':token' => $token,
      ':valid_until' => date('Y-m-d H:i:s', time() + 604800), // 7-days
    );

    if ($stmt->execute($params)) {
      \Huhu\Library\MemcacheManager::invalidateOnPushMethodsChange($currentUser['id']);
      return TRUE;
    }

    return FALSE;
  }

  /**
   * Generates a websocket token for authentificaton on websocket push server
   * and stores it to the pushauth db
   */
  public static function pushauthGenerateWebsocketToken() {
    \Huhu\Library\Auth::auth();
    $db=\Zend_Registry::get('Zend_Db');
    $currentUser=\Zend_Registry::get('loggedinuser');

    // generate a token
    $tokenUnencrypted=uniqid('WST-'.$currentUser['id'].'-', true);

    // encrypt the token
    $token=base64_encode(mcrypt_encrypt('cast-128', pack('H*', \Huhu\Library\Pusher_Websocket::$key), $tokenUnencrypted, MCRYPT_MODE_CFB, str_pad('0', 8)));


    // save the token
    $stmt=$db->prepare("INSERT INTO user_push_auth (`fk_userID`, `method`, `token`, `valid_until`)
                          VALUES(:fk_userID, :method, :token, :valid_until)
                          ON DUPLICATE KEY UPDATE `token`=:token, `valid_until`=:valid_until;");
    $params=Array(
      ':fk_userID' => $currentUser['id'],
      ':method' => 'websocket',
      ':token' => $tokenUnencrypted,
      ':valid_until' => date('Y-m-d H:i:s', time() + 86400), // 24-hours
    );

    if ($stmt->execute($params)) {
      \Huhu\Library\MemcacheManager::invalidateOnPushMethodsChange($currentUser['id']);
      return $token;
    }

    return FALSE;
  }

}